# 제가 제일 어려웠던 부분은 여러가지 있었지만 당장 생각나는 건 제가 채팅 기능을 구현했을 때입니다. 채팅 기능 구현이 처음이었는데, 저는 WebSocket, STOMP, Spring 내장 브로커를 사용해서 구현했습니다. 막상 구현은 무난하게 하였지만 이후가 문제였습니다. 채팅은 사용자 입력이 주를 이루는 서비스 이기 때문에 사용자 입력에 대한 예외처리와 채팅 서비스를 이용할 때 인증 방식에 대해서 어려움을 겪었습니다. 먼저 저는 제일 큰 문제였던 채팅 사용자가 무분별하게 혹은 부정프로그램을 사용해서 서버를 마비시킬 정도의 채팅 속도를 제한시키는 경우를 막기 위해 토큰 버킷 알고리즘을 기반으로 한 bucket4j 라이브러리를 사용해서 해결했습니다. resiliense4j와 rateLimitj도 고려 대상이었지만 rateLimitj는 공식 문서에서 더 이상 개발하지 않는다고 하였고 resilience4j는 MSA 아키텍쳐를 가진 프로젝트에서 많이 사용하며 러닝커브가 높아 bucket4j 를 이용하여 1초에 5번 이상 채팅을 치는 사용자를 10초 동안 채팅을 칠 수 없게 제한하였습니다. 
#
# 또 하나는 인증 관련 부분인데 처음 구현했을 때는 userId를 주고 받으면서 통신하였는데 이는 한 사용자가 userId만 바꿔보내면 얼마든지 다른 사용자로 사칭할 수 있었습니다. 이를 해결하기 위해 저는 Intercepter를 사용하여 해결했습니다. STOMP를 이용한 실시간 통신 시스템에서 사용자 세션을 유지하기 위해 WebSocket 연결 시 고유 세션 ID를 할당합니다. WebSocket으로 승격하기전에 HTTP 연결할 때 JWT를 사용해서 검증하고 STOMP 헤더에 userId 를 추가하고 웹소켓으로 업그레이드 요청을 합니다. 그리고 세션 ID를 할당 받으면 해당 세션 ID와 userId를 매핑시켜서 사용자 정보를 연결시켰습니다. 그래서 추후 메세지가 오면 세션 ID 를 통해 user를 검증하도록 하여 해결했습니다.